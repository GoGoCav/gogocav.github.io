<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Obj-c | Canvas Hsu]]></title>
  <link href="http://GoGoCav.github.io/blog/categories/obj-c/atom.xml" rel="self"/>
  <link href="http://GoGoCav.github.io/"/>
  <updated>2014-10-14T23:02:51+08:00</updated>
  <id>http://GoGoCav.github.io/</id>
  <author>
    <name><![CDATA[Canvas Hsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[笔记 - 类（Classes）和属性（Properties）]]></title>
    <link href="http://GoGoCav.github.io/blog/2014/10/13/note-of-class/"/>
    <updated>2014-10-13T23:13:32+08:00</updated>
    <id>http://GoGoCav.github.io/blog/2014/10/13/note-of-class</id>
    <content type="html"><![CDATA[<h2>笔记索引</h2>

<ol>
<li>类的初始化</li>
<li>类的属性用来存储数据</li>
<li>属性的特征

<ul>
<li>readwrite, readonly</li>
<li>atomic, nonatomic</li>
<li>strong, weak</li>
<li>copy</li>
</ul>
</li>
</ol>


<!-- more -->


<h2>ObjC 是一门动态语言</h2>

<p>每一个对象都通过指针来寻址。在运行时，才会根据指针指向的内存内容来确定对象的类型。</p>

<p>因此给指针给绑定的类型其实不重要。只要没有违反类的接口定义（例如你给某个对象的指针指定为 NSString 类型但是用该指针调用了一个不存在于 NSString 类中的方法），都可以通过编译。并且即便类型不对，在运行时也会根据指针找到并对象确定其正确的类型。</p>

<h2>类的初始化</h2>

<h4>语法形式</h4>

<p>对象是存储在 heap 上的一片内存，通过指针跟踪。创建对象的一般形式：</p>

<pre><code class="objc">ClassName *pointToObject = [[ClassName alloc] init];
</code></pre>

<p>init 方法的一般格式：</p>

<pre><code class="objc">- (id) init 
{
    self = [super init];
    if (self) {
        // 初始化代码
    }
    return self;
}
</code></pre>

<h4>知识要点</h4>

<ol>
<li><p>存储位置：
本地变量：stack 。因此变量不需要手工管理内存。
对象：heap 。因此对象需要内存管理。</p></li>
<li><p>alloc 和 init 要套用。避免 init 返回的指针对象和 alloc 分配的不同。</p></li>
<li><p>NSString，NSNumber等可以通过常量赋值的方式完成创建和初始化：
NSString *string = @“Hello World!”;
NSNumber *num = @3.14;</p></li>
<li><p>只有不含属性和参数的对象才能使用 new 创建。
统一起见建议统一使用 alloc init 方式创建对象。</p></li>
<li><p>标量变量（scalar variable）在定义时最好立即赋初始值。否则内部是 stack 上的一片野值。</p></li>
<li><p>指针在定义时默认指向nil，所以不立即赋值也可以。</p></li>
<li><p>对比两个对象：
== 对比两个对象指针是不是指向同一个地址；
isEqual: 和 compare: 等方法才比较两个对象的内容。</p></li>
<li><p>工厂方法用 id 做返回类型，用self来指自己，以子类继承使用。</p></li>
</ol>


<h2>类的属性用来存储数据</h2>

<p>大多数属性背后都有一个用来存放数据的实例变量。
编译器会为属性自动合成一个名为 _属性名的实例变量，实例方法可以直接访问它。</p>

<p>例如 @property NSString *firstName; 背后由编译器自动合成的实例变量为 NSString *_firstName。</p>

<p>如果要自己指定属性背后的实例变量名，使用如下语法：
<code>objc
@implementaition SomeClass
@synthesize propertyName = instanceVariableName;
...
@end
</code></p>

<h4>知识要点</h4>

<ol>
<li><p>init 方法中：要用属性的实例变量访问，不要用存取方法访问属性。
因为这时候对象还没有完全初始化完成。</p></li>
<li><p>存取方法也可以人工自己编写。在实现区块中实现对应的存取方法即可。</p></li>
</ol>


<h4>注意事项</h4>

<ol>
<li>编译器在自动合成存取方法同时自动合成属性的实例变量。
因此，如果人工指定了一个属性所有存取方法（只读属性的 getter 或读写属性的 setter 和 getter），则编译器也不会自动合成该属性的实例变量。这种情况下需要手工合成属性的实例变量：</li>
</ol>


<pre><code class="objc">@synthesize property = _property;
</code></pre>

<h2>属性的特征</h2>

<p>属性有如下几种特征：
- readwrite（默认），readonly 读写性
- atomic（默认），noatomic 原子性
- strong（默认），weak 强弱关系
- copy 复制</p>

<h3>读写性</h3>

<p>一个只读的属性在被初始化以后就不能再被重新赋值了，即使是属性所属的实例对象也不能再写入它。</p>

<h4>知识要点</h4>

<ol>
<li>除了初始化函数以外的函数都无法再对只读的属性重新赋值。类内部的函数也不行。</li>
</ol>


<h4>注意事项</h4>

<ol>
<li>但是可以通过属性背后的实例变量来修改只读属性的值。</li>
</ol>


<h3>原子性</h3>

<p>属性默认是原子性的。但是原子性的属性在读写时会占用更多资源。所以如果确定不会出现属性的原子性问题，可以将属性声明为非原子性的来提升性能。</p>

<h4>注意事项</h4>

<ol>
<li><p>atomic 属性的 getter 和 setter 方法要么都自动合成，要么都自己实现，不能混合（例如自动合成一个，自己实现另一个）</p></li>
<li><p>一个对象的所有属性都是 atomic 的，也不等于该对象为线程安全（thread safety）。atomic 属性的保护单元是单个属性，属性与属性之间的同步性无法保证。</p></li>
</ol>


<h3>强弱关系</h3>

<p>对象保存在 heap 上，因此内存是动态分配的。
我们只能通过指针跟踪 heap 上的对象，因此没有办法完全通过指针来判断它所指向的对象的生命周期。即使指针被释放了，也不表示它原来指向的内存可以被释放。</p>

<p>那如何管理对象的生命周期呢？换一个角度来思考：简单来说，如果一个对象不再被任何人需要的时候，它就可以被释放了。因此，管理对象的生命周期这个问题，可以转变为管理对象与对象之间的关系。如果一个对象被另一个对象引用，说明它还有存在的意义，那么它的生命周期就不能结束。</p>

<p>如果一个对象 A 依赖另一个对象 B ，我们就称作对象 A 拥有（take ownership of）对象 B，也称作对象 A 强引用（have strong reference to）对象 B。
例如：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">XYZPerson</span>
</span><span class='line'><span class="k">@property</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">firstName</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">hellip</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">XYZPerson</span> <span class="o">*</span><span class="n">aPerson</span> <span class="o">=</span> <span class="p">[[</span><span class="n">XYZPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">aPerson</span><span class="p">.</span><span class="n">firstName</span> <span class="o">=</span> <span class="p">@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Tommy</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;;</span>
</span></code></pre></td></tr></table></div></figure>
则 aPerson 这个对象强引用了 @“Tommy” 这个 NSString 对象。</p>

<p>那么如果对象 A 被释放，对象 B 就不被其他对象强引用了（假设之前只有 A 拥有 B），那么 B 也随之释放。这就是 Obj-C 中对对象的内存释放的规则。Obj-C 中默认引用关系是强引用。</p>

<p>那么如果两个对象互相依赖，即互相引用。最常见的两个对像互相引用的例子是 Delegation 设计模式中的委托对象（delegating object）和被委托对象（delegate object）。
如果两个对象互相强引用，就形成了一个强引用闭环，导致这两个对象都无法被释放。</p>

<p>因此引入了弱引用的概念：如果对象 A 弱引用对象 B，则 A 不构成对 B 的拥有。因此 B 的释放与否，与 A 是否引用自己无关。B 可以在 A 还弱引用着自己的情况下被释放。这样就可以打破强引用闭环。</p>

<p>在 Delegation 设计模式中，我们通常让委托对象弱引用它的被委托对象，被委托对象强引用委托自己的对象。</p>

<h4>语法格式</h4>

<p>声明弱引用：
<code>objc
    @property (weak) id someObject;
    NSObject * __weak someWeakVariable;
</code></p>

<h4>知识要点</h4>

<ol>
<li><p>如果指向一个对象的强引用数归零，则该对象也自动被释放。</p></li>
<li><p>弱引用不获得对被引用对象的所有权。因此被弱引用的对象可以在弱引用关系还存在的情况下被释放。当这种情况发生后，弱引用关系自动指向 nil。</p></li>
<li><p>有一部分的类不支持 weak 特征，只能使用 unsafe_unretained 特征。
unsafe_unretained 特征的差异是当被引用的对象被释后，引用对象不会自动指向nil，会变成一个野指针。</p></li>
</ol>


<h4>注意事项</h4>

<ol>
<li><p>由于 weak 变量会因为被引用的对象被释放而指向 nil，所以在使用 weak 变量时，有 weak 变量中途消失的风险。
为了防止这种风险，一般的做法是再声明一个新的对象强引用这个 weak 变量（相当于 cache 该 weak 变量所指向的对象，防止它被释放）。使用结束后将这个cache变量指针指向nil以释放对weak变量的强引用。</p></li>
<li><p>经典案例：
以下案例中新创建出来的对象由于没有任何其他对象强引用它，所以创建之后就被释放，因此someObject指向nil：
<code>
 NSObject * __weak someObject = [[NSObject alloc] init];
</code></p></li>
</ol>


<h2>复制</h2>

<p>如果希望一个属性对象首次被赋值后不因为赋给它的对象改变而改变，则可以在声明属性的时候加上 copy 特征字。具有 copy 特征的属性在首次赋值以后，会生成一份备份。之后如果被赋予的对象发生改变，也不会影响到该属性的值。</p>

<h4>语法格式</h4>

<pre><code>    @property (copy) NSObject someVariable;
</code></pre>

<h4>知识要点</h4>

<ol>
<li>只有支持 NSCopying 协议的对象才能被声明copy属性。</li>
</ol>


<h4>注意事项</h4>

<ol>
<li>如果对 copy 属性做初始化，一定要记得在初始化赋值的时候使用 copy 消息。
因为在 init 的时候是直接向属性背后的实例变量赋值。如果没有给被赋入的对象发送 copy 消息，会导致属性的 copy 特征失效。
举例：</li>
</ol>


<pre><code>    - (id)initWithString:(NSString *)aString 
    {
        self = [super init];
        if (self) {
            _instanceVariableForCopyProperty = [aMutableString copy];
        }
        return self;
    }
</code></pre>

<p>如果上例中直接采用 _instanceVariableForCopyProperty = aMutableString; 这样的初始化赋值，会导致 instanceVariableForCopyProperty 指向了一个可变字符串，当可变字符串变化时，该属性也随之变化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[笔记 - 类别（Category）和类扩展（Class Extention）]]></title>
    <link href="http://GoGoCav.github.io/blog/2014/10/13/note-of-category-and-class-extention/"/>
    <updated>2014-10-13T00:57:30+08:00</updated>
    <id>http://GoGoCav.github.io/blog/2014/10/13/note-of-category-and-class-extention</id>
    <content type="html"><![CDATA[<p>Objective-C 中如果想对类进行自定义和功能扩展，有2种常用技术：</p>

<ul>
<li>category 类别</li>
<li>class extention 类扩展</li>
</ul>


<p>两者有相似之处，也有区别。</p>

<h3>1. category 类别</h3>

<p>Category 可以给任何类（包括不是由你自己实现的类，比如框架类）增加方法或函数。该类和子类的所有实例都可以使用它们。在运行时，这些方法和函数与类原生的方法和函数没有任何差别。</p>

<!-- more -->


<h4>语法形式：</h4>

<p><em>ClassName+XYZCategoryName.h</em> (命名形式仅供参考，下同)</p>

<pre><code class="objc">@interface ClassName (XYZCategoryName)

# Category 不支持定义新的属性或实例变量

- (SomeClass *)xyz_someAdditionInstanceMethod;
+ (SomeClass *)xyz_someAdditionClassMethod; # Category 支持类方法

@end
</code></pre>

<p></br></p>

<p><em>ClassName+XYZCategoryName.m</em></p>

<pre><code class="objc">#import "ClassName+XYZCategoryName.h"

@implementation ClassName (XYZCategoryName)
- (SomeClass *)xyz_someAdditionInstanceMethod {
    # implement code here
}

+ (SomeClass *)xyz_someAdditionClassMethod {
    # implement code here
}
@end
</code></pre>

<h4>应用场景：</h4>

<ol>
<li>为类扩充功能。</li>
<li>如果一个类的功能复杂，可以将功能分类、拆分到不同的 categories 中，分别在独立的文件中声明和实现。</li>
</ol>


<h4>注意事项：</h4>

<ol>
<li>Category 不支持声明新的类属性或实例变量。（类扩展技术 Class Extensions 支持）。</li>
<li>Category 中新定义的方法或函数不能重名，建议对 category 名字和方法都增加前缀。</li>
</ol>


<p></br></p>

<h3>2. Class Extension 类扩展</h3>

<p>Class Extension 顾名思义是对类进行扩展，可以为有实现代码的类再声明一些新的属性、实例参数、方法或函数。</p>

<p>类扩展又被称为匿名类别（anonymous category），因为类扩展的声明就如同声明一个名字为空的类别。也因此，类扩展新声明的方法和函数的实现，写在类本身的@implementation 代码段中。</p>

<p>类扩展的 @interface 声明部分通常放到类实现所在的文件中，以达到类扩展私有化的目的。这也是类扩展最常用的场景。如果实在需要被外部的类访问类扩展的方法，则可以将类扩展的接口声明放到单独的 .h 头文件中，被需要它的代码引用。</p>

<h4>语法形式：</h4>

<pre><code class="objc">@interface ClassName () { # 类扩展也被称为匿名类别（anonymous categories）
    id _someExtendInstanceVariable; # 类扩展支持添加实例变量
}

@property SomeClass *someExtendProperty; # 类扩展支持添加属性

- (SomeObject *)someExtendMethod;

@end

...

@implementation ClassName

...

- (SomeObject *)someExtendMethod {
    # implement code here
}
...

@end
</code></pre>

<h4>应用场景：</h4>

<ol>
<li>通过类扩展隐藏一些私有信息。
例如想实现某个类属性对外只读、对内可写入的效果，则可以在类扩展中以 readwrite 重定义这个属性，为其添加写入权限，但将类扩展的接口声明放到类实现文件中，达到私有化的效果。因此做到了这个属性对外只读、对内可读写。</li>
<li>如果需要对某些特定的外部的类开通对类扩展私有方法或函数的访问，则可以将类扩展的接口声明放到独立的头文件中，供需要的代码引用。</li>
</ol>


<h4>注意事项：</h4>

<ol>
<li>类扩展可以声明新的属性和实例变量。这一点和类别不同。</li>
<li>类扩展只能用在拥有实现源代码的类上面，像框架类这种没有实现源码的类是不能扩展的。类扩展声明的新属性和实例变量需要和类的方法实现同时编译，这样编译器才能合成新属性的存取方法和实例变量。</li>
<li>类扩展的实现部分直接放到类本身的 @implementation 区块中。</li>
<li>如果外部对象访问类扩展的私有属性或方法，编译器会报警。但其实也有办法通过动态运行时的特征（例如利用 NSObjet 的 performSelector:&hellip; 方法）实现外部对象对私有的类扩展方法的调用。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译 - a Short Practical Guide to Blocks]]></title>
    <link href="http://GoGoCav.github.io/blog/2014/10/11/translation-a-short-practical-guide-to-blocks/"/>
    <updated>2014-10-11T20:45:46+08:00</updated>
    <id>http://GoGoCav.github.io/blog/2014/10/11/translation-a-short-practical-guide-to-blocks</id>
    <content type="html"><![CDATA[<h3>写在前面</h3>

<p>这是我的原创翻译的第一篇。</p>

<p>近期在阅读苹果官方文档的时候，突然萌生了想要翻译它的想法。一来是觉得可以加强阅读质量、加深印象，二来也可以练习一下英语理解能力，第三也是觉得可以为那些不愿意阅读英文文档的朋友尽一点微薄之力。反正现在没有工作，也是有些时间的（笑）。所以没有经过太多考虑，就开始做了起来。</p>

<p>对于翻译的原则，我是以严格尊重原著的表达方式为主，再根据中文的语言习惯和方便理解为目的进行微量的语法调整。出于对科学的谨慎和尊重（其实也是对自己的英语能力的担忧哈哈，毕竟只是六级水准），对于语法结构比较复杂的长句，我都会反复斟酌和理解，力求没有偏译。对于一些特定的专有名词，我也尽可能查阅相关资料寻求中文环境中最普遍的对应词汇。</p>

<p>希望我的这点工作能对一些人产生帮助。
如果对某些翻译存在异议，或者您也想加入我一起进行苹果文档的翻译工作，随时欢迎留言 ：D</p>

<!-- more -->


<hr />

<h1>A Short Practical Guide to Blocks</h1>

<h2>“块”的简要实践指南</h2>

<p><em>原文地址：<a href="https://developer.apple.com/library/ios/featuredarticles/Short_Practical_Guide_Blocks/index.html#//apple_ref/doc/uid/TP40009758-CH1-SW1">iOS Developer Library</a></em></p>

<p><em>译者：<a href="http://gogocav.github.io">Canvas Hsu</a></em></p>

<p><em>日期：2014-10-11</em></p>

<p>Blocks are a powerful C-language feature that is part of Cocoa application development. They are similar to “closures” and “lambdas” you may find in scripting and programming languages such as Ruby, Python, and Lisp. Although the syntax and storage details of blocks might at first glance seem cryptic, you’ll find that it’s actually quite easy to incorporate blocks into your projects’ code.</p>

<blockquote><p>“块”作为 Cocoa 应用开发的一部分，是一个非常强大的 C 语言特性。它很像你在 Ruby、Python、Lisp 等脚本语言和编程语言中碰到的 “闭包”和“匿名函数”。虽然块的语法和存储细节第一眼看上去很晦涩，最终你将发现在你的项目编码中使用块实际上是非常简单的。</p></blockquote>

<p>The following discussion gives a high-level survey of the features of blocks and illustrates the typical ways in which they are used. Refer to <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502">Blocks Programming Topics</a> for the definitive description of blocks.</p>

<blockquote><p>接下来的讨论将从高层次观察一些块的特性，并描绘一些块的典型用法。关于块的明确说明，可以参阅<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502">块编程主题</a>文档。</p></blockquote>

<h3>Contents:</h3>

<ul>
<li>Why Use Blocks?</li>
<li>Blocks in the System Framework APIs</li>
<li>Blocks and Concurrency</li>
</ul>


<h4>Why Use Blocks?</h4>

<h4>为什么用块？</h4>

<p>Blocks are objects that encapsulate a unit of work—or, in less abstract terms, a segment of code—that can be executed at any time. They are essentially portable and anonymous functions that one can pass in as arguments of methods and functions or that can be returned from methods and functions. Blocks themselves have a typed argument list and may have inferred or declared returned type. You may also assign a block to a variable and then call it just as you would a function.</p>

<blockquote><p>块是一个封装了一组任务的对象，稍微具体一点说，是一段代码，它能随时被执行。块本质上是具有可移植性、并可以作为方法或函数的入参或者返回值的匿名函数。块自身有一个指定类型的参数列表，也可以有可推断或声明类型的返回值。你还可以将块分配给一个变量，然后像调用函数一样调用块。</p></blockquote>

<p>The caret symbol (^) is used as a syntactic marker for blocks. For example, the following code declares a block variable taking two integers and returning an integer value. It provides the parameter list after the second caret and the implementing code within the braces, and assigns these to the Multiply variable:</p>

<pre><code class="objc">int (^Multiply)(int, int) = ^(int num1, int num2) {
    return num1 * num2;
};
int result = Multiply(7, 4); // Result is 28.
</code></pre>

<p>As method or function arguments, blocks are a type of callback and could be considered a form of delegation limited to the method or function. By passing in a block, calling code can customize the behavior of a method or function. When invoked, the method or function performs some work and, at the appropriate moments, calls back to the invoking code—via the block—to request additional information or to obtain application-specific behavior from it.</p>

<blockquote><p>当块作为方法或函数的参数时，是一种回调的形式，可以被理解为方法或函数的一种委托形式。通过传入一个块，调用代码可以定制方法或函数的行为表现。方法或函数被调用后完成特定的工作，然后在合适的时机通过块来回调调用方法或函数的代码，通过这种方式请求一些额外的信息或者申请特定的行为许可。</p></blockquote>

<p>An advantage of blocks as function and method parameters is that they enable the caller to provide the callback code at the point of invocation. Because this code does not have to be implemented in a separate method or function, your implementation code can be simpler and easier to understand. Take notifications of the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotification_Class/index.html#//apple_ref/occ/cl/NSNotification">NSNotification</a> variety as an example. In the “traditional” approach, an object adds itself as an observer of a notification and then implements a separate method (identified by a selector in the addObserver:.. method) to handle the notification:</p>

<blockquote><p>将块作为函数和方法的参数的一个好处是：块让调用者提供了函数和方法在被援引时的回调代码。因为这部分代码不需要在单独的方法或函数中实现，所以你的实现代码会更简单易懂。下面以 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotification_Class/index.html#//apple_ref/occ/cl/NSNotification">NSNotification</a> 的通知变量为例。“传统”的实现方法是，一个对象将自身添加为一个通知的观察者，然后单独定义一个方法（通过 addObserver:.. 方法中的 selector 指定）来处理通知：</p></blockquote>

<pre><code class="objc">- (void)viewDidLoad {
   [super viewDidLoad];
    [[NSNotificationCenter defaultCenter] addObserver:self
        selector:@selector(keyboardWillShow:)
        name:UIKeyboardWillShowNotification object:nil];
}

- (void)keyboardWillShow:(NSNotification *)notification {
    // Notification-handling code goes here.
}
</code></pre>

<p>With the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/index.html#//apple_ref/occ/instm/NSNotificationCenter/addObserverForName:object:queue:usingBlock:">addObserverForName:object:queue:usingBlock:</a> method you can consolidate the notification-handling code with the method invocation:</p>

<blockquote><p>通过使用<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/index.html#//apple_ref/occ/instm/NSNotificationCenter/addObserverForName:object:queue:usingBlock:">addObserverForName:object:queue:usingBlock:</a>这个方法，你可以将通知处理操作以块的形式整合到方法的调用上。</p></blockquote>

<pre><code class="objc">- (void)viewDidLoad {
    [super viewDidLoad];
    [[NSNotificationCenter defaultCenter] addObserverForName:UIKeyboardWillShowNotification
        object:nil queue:[NSOperationQueue mainQueue]
        usingBlock:^(NSNotification *notif) {
            // Notification-handling code goes here. 
    }];
}
</code></pre>

<p>An even more valuable advantage of blocks over other forms of callback is that a block shares data in the local lexical scope. If you implement a method and in that method define a block, the block has access to the local variables and parameters of the method (including stack variables) as well as to functions and global variables, including instance variables. This access is read-only by default, but if you declare a variable with the __block modifier, you can change its value within the block. Even after the method or function enclosing a block has returned and its local scope is destroyed, the local variables persist as part of the block object as long as there is a reference to the block.</p>

<blockquote><p>相较于其他形式的回调，块有一个优势，那就是一个块可以在本地词汇范围内共享数据。如果你实现一个方法，然后在这个方法中定义一个块，这个块就可以访问这个方法里的本地变量和参数（包括栈里的变量），就和它能访问函数、全局变量，包括市里变量一样。这种访问默认是只读的，但是你可以在声明一个变量时使用 __block 修饰词，这样的变量就可以被块修改赋值。甚至当这个包含块的方法或函数已经经返回了、本地范围已经销毁了，只要这个块还被某个对象引用着，这些本地变量依然作为块对象的一部分继续存在。</p></blockquote>

<h4>Blocks in the System Framework APIs</h4>

<h4>块在系统框架 API 中的应用</h4>

<p>One obvious motivation for using blocks is that an increasing number of the methods and functions of the system frameworks take blocks as parameters. One can discern a half-dozen or so use cases for blocks in framework methods:</p>

<blockquote><p>在系统框架中，块被越来越多的作为框架方法和函数的参数来使用。在以下这些框架方法中，可以看到非常多的块的使用案例：</p></blockquote>

<ul>
<li>Completion handlers</li>
<li>Notification handlers</li>
<li>Error handlers</li>
<li>Enumeration</li>
<li>View animation and transitions</li>
<li>Sorting</li>
</ul>


<p>The sections that follow describe each of these cases. But before we get to that, here is a quick overview on interpreting block declarations in framework methods. Consider the following method of the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSSet_Class/index.html#//apple_ref/occ/cl/NSSet">NSSet</a> class:</p>

<blockquote><p>接下来的章节会逐一描述上述这些案例。在此之前，我们先快速的了解一下在框架方法中，块是怎样声明的。以 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSSet_Class/index.html#//apple_ref/occ/cl/NSSet">NSSet</a> 类的一个方法为例：</p></blockquote>

<pre><code class="objc">- (NSSet *)objectsPassingTest:(BOOL (^)(id obj, BOOL *stop))predicate
</code></pre>

<p>The block declaration indicates that the method passes into the block (for each enumerated item) a dynamically typed object and a by-reference Boolean value; the block returns a Boolean value. (What these parameters and return value are actually for are covered in <a href="https://developer.apple.com/library/ios/featuredarticles/Short_Practical_Guide_Blocks/index.html#//apple_ref/doc/uid/TP40009758-CH1-SW1">Enumeration</a>.) When specifying your block, begin with a caret (^) and the parenthesized argument list; follow this with the block code itself, enclosed by braces.</p>

<blockquote><p>从块的声明可以看到，这个方法对每一个枚举项都向块传入两个参数：一个动态类型的对象和一个布尔类型的指针；块再返回一个布尔类型的值。（关于这些参数和返回值的具体含义请参考 <a href="https://developer.apple.com/library/ios/featuredarticles/Short_Practical_Guide_Blocks/index.html#//apple_ref/doc/uid/TP40009758-CH1-SW1">Enumeration</a> 章节。）块的声明是用一个脱字号(^)开头，再用圆括号包住参数列表；之后用花括号包住块体的代码。</p></blockquote>

<pre><code class="objc">[mySet objectsPassingTest:^(id obj, BOOL *stop) {
    // Code goes here: Return YES if obj passes the test and NO if obj does not pass the test.
}];
</code></pre>

<h4>Completion and Error Handlers</h4>

<h4>完成和错误处理程序</h4>

<p>Completion handlers are callbacks that allow a client to perform some action when a framework method or function completes its task. Often the client uses a completion handler to free state or update the user interface. Several framework methods let you implement completion handlers as blocks (instead of, say, delegation methods or notification handlers).</p>

<blockquote><p>完成处理程序(comletion handlers)是回调程序，客户端可以通过它在一个框架方法或函数执行完毕以后再进行一些处理。通常客户端用完成处理函数来释放空间或更新用户界面。有一些框架方法允许你使用块来作为完成处理程序（代替通常被作为完成处理程序的代理方法或者通知程序）。</p></blockquote>

<p>The <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/cl/UIView">UIView</a> class has several class methods for animations and view transitions that have completion-handler block parameters. ( <a href="https://developer.apple.com/library/ios/featuredarticles/Short_Practical_Guide_Blocks/index.html#//apple_ref/doc/uid/TP40009758-CH1-SW31">View Animation and Transitions</a> gives an overview of these methods.) The example in Listing 1-1 shows an implementation of the <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/clm/UIView/animateWithDuration:animations:completion:">animateWithDuration:animations:completion:</a> method. The completion handler in this example resets the animated view back to its original location and transparency (alpha) value a few seconds after the animation concludes.</p>

<blockquote><p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/cl/UIView">UIView</a> 类有一些操作动画和视图过渡的类方法可以使用块作为完成处理程序。（在 <a href="https://developer.apple.com/library/ios/featuredarticles/Short_Practical_Guide_Blocks/index.html#//apple_ref/doc/uid/TP40009758-CH1-SW31">视图动画和过渡</a> 章节有对这些方法的概述。）Listing 1-1 的例子展示了 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/clm/UIView/animateWithDuration:animations:completion:">animateWithDuration:animations:completion:</a> 方法是如何实现的。在这个例子中，完成处理程序在视图动画完成以后，重置该视图的初始位置和透明度。</p></blockquote>

<p><strong>Listing 1-1</strong> A completion-handler block</p>

<pre><code class="objc">- (IBAction)animateView:(id)sender {
    CGRect cacheFrame = self.imageView.frame;
    [UIView animateWithDuration:1.5 animations:^{
        CGRect newFrame = self.imageView.frame;
        newFrame.origin.y = newFrame.origin.y + 150.0;
        self.imageView.frame = newFrame;
        self.imageView.alpha = 0.2;
    }
                    completion:^ (BOOL finished) {
                        if (finished) {
                            // Revert image view to original.
                            self.imageView.frame = cacheFrame;
                            self.imageView.alpha = 1.0;
                         }
    }];
}
</code></pre>

<p>Some framework methods have error handlers, which are block parameters similar to completion handlers. The method invokes them (and passes in an <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/index.html#//apple_ref/occ/cl/NSError">NSError</a> object) when it cannot complete its task because of some error condition. You typically implement an error handler to inform the user about the error.</p>

<blockquote><p>类似的，有一些框架方法也支持用块作为错误处理程序（error handlers）。这些方法在程序因为某些错误无法完成时调用块（并传入一个 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/index.html#//apple_ref/occ/cl/NSError">NSError</a> 类型的对象）。通常错误处理程序用来将错误通知给用户。</p></blockquote>

<h4>Notification Handlers</h4>

<h4>通知处理程序</h4>

<p>The NSNotificationCenter method <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/index.html#//apple_ref/occ/instm/NSNotificationCenter/addObserverForName:object:queue:usingBlock:">addObserverForName:object:queue:usingBlock:</a> lets you implement the handler for a notification at the point you set up the observation. Listing 1-2 illustrates how you might call this method, defining a block handler for the notification. As with notification-handler methods, an <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotification_Class/index.html#//apple_ref/occ/cl/NSNotification">NSNotification</a> object is passed in. The method also takes an <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/index.html#//apple_ref/occ/cl/NSOperationQueue">NSOperationQueue</a> instance, so your application can specify an execution context on which to run the block handler.</p>

<blockquote><p>NSNotificationCenter 类的 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/index.html#//apple_ref/occ/instm/NSNotificationCenter/addObserverForName:object:queue:usingBlock:">addObserverForName:object:queue:usingBlock:</a> 方法允许你对某个通知设定一个处理程序，该程序在你为这个通知设置了观察者时执行。Listing 1-2 的例子展示了如何在调用这个方法时用块作为通知处理程序。通知处理方法会传入一个 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotification_Class/index.html#//apple_ref/occ/cl/NSNotification">NSNotification</a> 对象到块里。同时该方法还有一个<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/index.html#//apple_ref/occ/cl/NSOperationQueue">NSOperationQueue</a> 类型的实例参数，该实例让应用知道在怎样的特定环境下执行这个块。</p></blockquote>

<p><strong>Listing 1-2</strong> Adding an object as an observer and
handling a notification using a block</p>

<pre><code class="objc">- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {
    opQ = [[NSOperationQueue alloc] init];
    [[NSNotificationCenter defaultCenter] addObserverForName:@"CustomOperationCompleted"
            object:nil queue:opQ
        usingBlock:^(NSNotification *notif) {
        NSNumber *theNum = [notif.userInfo objectForKey:@"NumberOfItemsProcessed"];
        NSLog(@"Number of items processed: %i", [theNum intValue]);
    }];
}
</code></pre>

<h4>Enumeration</h4>

<h4>枚举</h4>

<p>The collection classes of the Foundation framework—<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/index.html#//apple_ref/occ/cl/NSArray">NSArray</a>, <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSDictionary_Class/index.html#//apple_ref/occ/cl/NSDictionary">NSDictionary</a>, <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSSet_Class/index.html#//apple_ref/occ/cl/NSSet">NSSet</a>, and <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSIndexSet_Class/index.html#//apple_ref/occ/cl/NSIndexSet">NSIndexSet</a>—declare methods that perform the enumeration of a particular type of collection and that specify blocks for clients to supply code to handle or test each enumerated item. In other words, the methods perform the equivalent of the fast-enumeration construct:</p>

<blockquote><p>Foundation 框架中的集合类型（<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/index.html#//apple_ref/occ/cl/NSArray">NSArray</a>， <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSDictionary_Class/index.html#//apple_ref/occ/cl/NSDictionary">NSDictionary</a>， <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSSet_Class/index.html#//apple_ref/occ/cl/NSSet">NSSet</a>，和 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSIndexSet_Class/index.html#//apple_ref/occ/cl/NSIndexSet">NSIndexSet</a>）声明了一些针对特定集合的枚举方法，这些方法支持客户端利用块代码来操作或测试每一个枚举项。换句话说，这些方法实现了和下面这种快速枚举结构相同的功能：</p></blockquote>

<pre><code class="objc"> for (id item in collection) {
    // Code to operate on each item in turn.
}
</code></pre>

<p>There are two general forms of the enumeration methods that take blocks. The first are methods whose names begin with enumerate and do not return a value. The block for these methods performs some work on each enumerated item. The block parameter of the second type of method is preceded by passingTest; this kind of method returns an integer or an NSIndexSet object. The block for these methods performs a test on each enumerated item and returns YEStrue if the item passes the test. The integer or index set identifies the object or objects in the original collection that passed the test.</p>

<blockquote><p>枚举方法使用块的形式主要有两种。第一种是以 enumerate 开头命名、并且没有返回值的方法。块在这些方法中对每一个枚举项都执行一些操作。第二种形式是块以名为 passingTest 的参数形式传入方法，这一类方法返回一个整型数值或者一个 NSIndexSet 对象。在这类方法中，块对每一个枚举项都执行一套测试，然后对测试通过的枚举项返回 YEStrue 。方法的整型数值或 NSIndexSet 对象返回值标识出原来的集合中通过了测试的对象或对象集。</p></blockquote>

<p>The code in Listing 1-3 calls an NSArray method of each of these types. The block of the first method (a “passing test” method) returns YEStrue for every string in an array that has a certain prefix. The code subsequently creates a temporary array using the index set returned from the method. The block of the second method trims away the prefix from each string in the temporary array and adds it to a new array.</p>

<blockquote><p>例子 Listing 1-3 中的代码调用了一个 NSArray 的方法，案例中对上述两种应用形式都有使用。在第一个方法中（一个”通过测试”的方法），块对数组中每一个以特定前缀命名的字符串对象返回 YEStrue。接下来的代码通过从第一个方法中得到的索引组创建了一个临时数组。第二个方法中的块枚举临时数组中的每一个字符串，去掉它们的前缀再放入一个新数组中。</p></blockquote>

<p><strong>Listing 1-3</strong> Processing enumerated arrays using two blocks</p>

<pre><code class="objc">NSString *area = @"Europe";
NSArray *timeZoneNames = [NSTimeZone knownTimeZoneNames];
NSMutableArray *areaArray = [NSMutableArray arrayWithCapacity:1];
NSIndexSet *areaIndexes = [timeZoneNames indexesOfObjectsWithOptions:NSEnumerationConcurrent
                                passingTest:^(id obj, NSUInteger idx, BOOL *stop) {
    NSString  *tmpStr = (NSString *)obj;
    return [tmpStr hasPrefix:area];
}];

NSArray *tmpArray = [timeZoneNames objectsAtIndexes:areaIndexes];
[tmpArray enumerateObjectsWithOptions:NSEnumerationConcurrent|NSEnumerationReverse
                           usingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
                               [areaArray addObject:[obj substringFromIndex:[area length]+1]];
}];
NSLog(@"Cities in %@ time zone:%@", area, areaArray);
</code></pre>

<p>The stop parameter in each of these enumeration methods (which is not used in the example) allows the block to pass YEStrue by reference back to the method to tell it to quit enumerating. You do this when you just want to find the first item in the collection that matches some criteria.</p>

<blockquote><p>每一个上面列举的这种枚举方法中都有一个名为 stop 的参数（在上个例子中没有被使用到），这个参数允许块通过引用回传 YEStrue 给方法，让方法退出枚举。当你只需要找出第一个符合特定条件的项时可以这么做。</p></blockquote>

<p>Even though it does not represent a collection, the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/cl/NSString">NSString</a> class also has two methods with block parameters whose names begin with enumerate: <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/instm/NSString/enumerateSubstringsInRange:options:usingBlock:">enumerateSubstringsInRange:options:usingBlock:</a> and <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/instm/NSString/enumerateLinesUsingBlock:">enumerateLinesUsingBlock:</a>. The first method enumerates a string by a text unit of a specified granularity (line, paragraph, word, sentence, and so on); the second method enumerates it by line only. Listing 1-4 illustrates how you might use the first method.</p>

<blockquote><p>虽然 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/cl/NSString">NSString</a> 不是表现集合的类，但它也有两个以 enumerate 开头命名的包含块参数的方法：
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/instm/NSString/enumerateSubstringsInRange:options:usingBlock:">enumerateSubstringsInRange:options:usingBlock:</a> 和 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/instm/NSString/enumerateLinesUsingBlock:">enumerateLinesUsingBlock:</a> 。第一个方法通过指定粒度（例如行、段落、单词、句子等等）将一个字符串分成一个个文本单元进行枚举；第二个方法则以行为单元来枚举字符串。Listing 1-4 的案例描绘了第一个方法的应用场景。</p></blockquote>

<p><strong>Listing 1-4</strong> Using a block to find matching substrings in a string</p>

<pre><code class="objc">NSString *musician = @"Beatles";
NSString *musicDates = [NSString stringWithContentsOfFile:
    @"/usr/share/calendar/calendar.music"
    encoding:NSASCIIStringEncoding error:NULL];
[musicDates enumerateSubstringsInRange:NSMakeRange(0, [musicDates length]-1)
    options:NSStringEnumerationByLines
    usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) {
           NSRange found = [substring rangeOfString:musician];
           if (found.location != NSNotFound) {
                NSLog(@"%@", substring);
           }
      }];
</code></pre>

<h4>View Animation and Transitions</h4>

<h4>视图动画和过渡</h4>

<p>The <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/cl/UIView">UIView</a> class in iOS 4.0 introduced several class methods for animation and view transitions that take blocks. The block parameters are of two kinds (not all methods take both kinds):
- Blocks that change the view properties to be animated
- Completion handlers</p>

<blockquote><p>iOS 4.0 的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/cl/UIView">UIView</a> 类中新增了几个关于动画和视图过渡的类方法，在这些类方法中使用到了块。这些块参数分为两种类型（不是所有的方法都同时使用到了这两种类型）：
 - 通过块改变视图的属性来形成动画
 - 将块做为完成处理程序</p></blockquote>

<p>Listing 1-5 shows an invocation of <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/clm/UIView/animateWithDuration:animations:completion:">animateWithDuration:animations:completion:</a>, a method that has both kinds of block parameters. In this example, the animation makes the view disappear (by specifying zero alpha) and the completion handler removes it from its superview.</p>

<blockquote><p>Listing 1-5 展示了一个调用 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/clm/UIView/animateWithDuration:animations:completion:">animateWithDuration:animations:completion:</a> 方法的例子，这个方法中同时包含了上述两种块参数的应用类型。在这个例子中，动画让视图消失（通过调整透明度为 0 ）然后完成处理程序将视图从父视图中移除。</p></blockquote>

<p><strong>Listing 1-5</strong> Simple animation of a view using blocks</p>

<pre><code class="objc">[UIView animateWithDuration:0.2 animations:^{
        view.alpha = 0.0;
    } completion:^(BOOL finished){
        [view removeFromSuperview];
    }];
</code></pre>

<p>Other UIView class methods perform transitions between two views, including flips and curls. The example invocation of <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/clm/UIView/transitionWithView:duration:options:animations:completion:">transitionWithView:duration:options:animations:completion:</a> in Listing 1-6 animates the replacement of a subview as a flip-left transition. (It does not implement a completion handler.)</p>

<blockquote><p>其他 UIView 类的方法实现两个视图之间的过渡，比如翻转和弯曲。案例 Listing 1-6 调用 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/clm/UIView/transitionWithView:duration:options:animations:completion:">transitionWithView:duration:options:animations:completion:</a> 方法实现了一个子视图向左翻转消失的动画效果。（这个方法没有实现完成处理程序）</p></blockquote>

<p><strong>Listing 1-6</strong> Implementing a flip transition between two views</p>

<pre><code class="objc">[UIView transitionWithView:containerView duration:0.2
                   options:UIViewAnimationOptionTransitionFlipFromLeft
                animations:^{
                    [fromView removeFromSuperview];
                    [containerView addSubview:toView]
                }
                completion:NULL];
</code></pre>

<h4>Sorting</h4>

<h4>排序</h4>

<p>The Foundation framework declares the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/index.html#//apple_ref/c/tdef/NSComparator">NSComparator</a> type for comparing two items:</p>

<blockquote><p>在 Foundation 框架中有一个 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/index.html#//apple_ref/c/tdef/NSComparator">NSComparator</a> 类型用于比较两个项目：</p></blockquote>

<pre><code class="objc">typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);
</code></pre>

<p>NSComparator is a block type that takes two objects and returns an <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/c/tdef/NSComparisonResult">NSComparisonResult</a> value. It is a parameter in methods of <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSSortDescriptor_Class/index.html#//apple_ref/occ/cl/NSSortDescriptor">NSSortDescriptor</a>, <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/index.html#//apple_ref/occ/cl/NSArray">NSArray</a>, and <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSDictionary_Class/index.html#//apple_ref/occ/cl/NSDictionary">NSDictionary</a> and is used by instances of those classes for sorting. Listing 1-7 gives an example of its use.</p>

<blockquote><p>NSComparator 是一个块的类型，它获得两个对象并返回一个<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/c/tdef/NSComparisonResult">NSComparisonResult</a> 类的值。它是
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSSortDescriptor_Class/index.html#//apple_ref/occ/cl/NSSortDescriptor">NSSortDescriptor</a>， <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/index.html#//apple_ref/occ/cl/NSArray">NSArray</a>，和 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSDictionary_Class/index.html#//apple_ref/occ/cl/NSDictionary">NSDictionary</a> 这些类的方法的参数，被这些类的实例用于排序。Listing 1-7 展示了这种应用。</p></blockquote>

<p><strong>Listing 1-7</strong> Sorting an array using an NSComparator block</p>

<pre><code class="objc">NSArray *stringsArray = [NSArray arrayWithObjects:
                                 @"string 1",
                                 @"String 21",
                                 @"string 12",
                                 @"String 11",
                                 @"String 02", nil];
static NSStringCompareOptions comparisonOptions = NSCaseInsensitiveSearch | NSNumericSearch |
        NSWidthInsensitiveSearch | NSForcedOrderingSearch;
NSLocale *currentLocale = [NSLocale currentLocale];
NSComparator finderSort = ^(id string1, id string2) {
    NSRange string1Range = NSMakeRange(0, [string1 length]);
    return [string1 compare:string2 options:comparisonOptions range:string1Range locale:currentLocale];
};
NSLog(@"finderSort: %@", [stringsArray sortedArrayUsingComparator:finderSort]);
</code></pre>

<p>This example is taken from <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502">Blocks Programming Topics</a>.</p>

<blockquote><p>这个例子来自 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502">块编程主题</a> 文档。</p></blockquote>

<h4>Blocks and Concurrency</h4>

<h4>块和并发</h4>

<p>Blocks are portable and anonymous objects encapsulating a unit of work that can be performed asynchronously at a later time. Because of this essential fact, blocks are a central feature of both Grand Central Dispatch (GCD) and the  <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/index.html#//apple_ref/occ/cl/NSOperationQueue">NSOperationQueue</a> class, the two recommended technologies for concurrent processing.</p>

<blockquote><p>块具有可移植性，并且使用匿名对象来封装一段任务代码，可以被异步地调用。因此，块是中央调度（Grand Central Dispatch (GCD)）和   <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/index.html#//apple_ref/occ/cl/NSOperationQueue">NSOperationQueue</a> 类这两个推荐的并发处理技术的主要特色。</p></blockquote>

<ul>
<li>The two central functions of GCD, <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_sync">dispatch_sync(3) OS X Developer Tools Manual Page</a> (for synchronous dispatching) or <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_async">dispatch_async(3) OS X Developer Tools Manual Page</a> (for asynchronous dispatching) take as their second arguments a block.</li>
<li>An NSOperationQueue is an object that schedules tasks to be performed concurrently or in an order defined by dependency relationships. The tasks are represented by <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html#//apple_ref/occ/cl/NSOperation">NSOperation</a> objects, which frequently use blocks to implement their tasks.</li>
</ul>


<blockquote><ul>
<li><p>中央调度（GCD）的两个核心函数<a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_sync">dispatch_sync(3) OS X Developer Tools Manual Page</a> （用于同步调度）和 <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_async">dispatch_async(3) OS X Developer Tools Manual Page</a> （用于异步调度）都采用块作为它们的第二个参数。</p></li>
<li><p>通过 NSOperationQueue 对象，调度任务可以被同时执行，或由依赖关系所限定的顺序依次执行。</p></li>
</ul>
</blockquote>

<p>For more about GCD, NSOperationQueue, and NSOperation, see <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091">Concurrency Programming Guide</a>.</p>

<blockquote><p>更多关于 GCD、NSOperationQueue 和 NSOperation 的信息，可以参阅 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091">Concurrency Programming Guide</a> 文档。</p></blockquote>

<p>-END-</p>
]]></content>
  </entry>
  
</feed>
